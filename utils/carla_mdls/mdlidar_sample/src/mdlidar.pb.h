// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mdlidar.proto

#ifndef PROTOBUF_mdlidar_2eproto__INCLUDED
#define PROTOBUF_mdlidar_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace mdlidar {
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Orientation;
class OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Vector3D;
class Vector3DDefaultTypeInternal;
extern Vector3DDefaultTypeInternal _Vector3D_default_instance_;
}  // namespace mdlidar

namespace mdlidar {

namespace protobuf_mdlidar_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mdlidar_2eproto

// ===================================================================

class Vector3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.Vector3D) */ {
 public:
  Vector3D();
  virtual ~Vector3D();

  Vector3D(const Vector3D& from);

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3D& default_instance();

  static inline const Vector3D* internal_default_instance() {
    return reinterpret_cast<const Vector3D*>(
               &_Vector3D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Vector3D* other);
  void Swap(Vector3D* other);

  // implements Message ----------------------------------------------

  inline Vector3D* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3D& from);
  void MergeFrom(const Vector3D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3D* other);
  protected:
  explicit Vector3D(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:mdlidar.Vector3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Orientation* other);
  void Swap(Orientation* other);

  // implements Message ----------------------------------------------

  inline Orientation* New() const PROTOBUF_FINAL { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Orientation* other);
  protected:
  explicit Orientation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mdlidar.Vector3D axis = 1;
  bool has_axis() const;
  void clear_axis();
  static const int kAxisFieldNumber = 1;
  private:
  void _slow_mutable_axis();
  void _slow_set_allocated_axis(
      ::google::protobuf::Arena* message_arena, ::mdlidar::Vector3D** axis);
  ::mdlidar::Vector3D* _slow_release_axis();
  public:
  const ::mdlidar::Vector3D& axis() const;
  ::mdlidar::Vector3D* mutable_axis();
  ::mdlidar::Vector3D* release_axis();
  void set_allocated_axis(::mdlidar::Vector3D* axis);
  ::mdlidar::Vector3D* unsafe_arena_release_axis();
  void unsafe_arena_set_allocated_axis(
      ::mdlidar::Vector3D* axis);

  // float angle = 2;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  float angle() const;
  void set_angle(float value);

  // @@protoc_insertion_point(class_scope:mdlidar.Orientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mdlidar::Vector3D* axis_;
  float angle_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(State* other);
  void Swap(State* other);

  // implements Message ----------------------------------------------

  inline State* New() const PROTOBUF_FINAL { return New(NULL); }

  State* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(State* other);
  protected:
  explicit State(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mdlidar.Vector3D position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  void _slow_mutable_position();
  void _slow_set_allocated_position(
      ::google::protobuf::Arena* message_arena, ::mdlidar::Vector3D** position);
  ::mdlidar::Vector3D* _slow_release_position();
  public:
  const ::mdlidar::Vector3D& position() const;
  ::mdlidar::Vector3D* mutable_position();
  ::mdlidar::Vector3D* release_position();
  void set_allocated_position(::mdlidar::Vector3D* position);
  ::mdlidar::Vector3D* unsafe_arena_release_position();
  void unsafe_arena_set_allocated_position(
      ::mdlidar::Vector3D* position);

  // .mdlidar.Orientation orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  private:
  void _slow_mutable_orientation();
  void _slow_set_allocated_orientation(
      ::google::protobuf::Arena* message_arena, ::mdlidar::Orientation** orientation);
  ::mdlidar::Orientation* _slow_release_orientation();
  public:
  const ::mdlidar::Orientation& orientation() const;
  ::mdlidar::Orientation* mutable_orientation();
  ::mdlidar::Orientation* release_orientation();
  void set_allocated_orientation(::mdlidar::Orientation* orientation);
  ::mdlidar::Orientation* unsafe_arena_release_orientation();
  void unsafe_arena_set_allocated_orientation(
      ::mdlidar::Orientation* orientation);

  // .mdlidar.Vector3D position_p = 3;
  bool has_position_p() const;
  void clear_position_p();
  static const int kPositionPFieldNumber = 3;
  private:
  void _slow_mutable_position_p();
  void _slow_set_allocated_position_p(
      ::google::protobuf::Arena* message_arena, ::mdlidar::Vector3D** position_p);
  ::mdlidar::Vector3D* _slow_release_position_p();
  public:
  const ::mdlidar::Vector3D& position_p() const;
  ::mdlidar::Vector3D* mutable_position_p();
  ::mdlidar::Vector3D* release_position_p();
  void set_allocated_position_p(::mdlidar::Vector3D* position_p);
  ::mdlidar::Vector3D* unsafe_arena_release_position_p();
  void unsafe_arena_set_allocated_position_p(
      ::mdlidar::Vector3D* position_p);

  // .mdlidar.Orientation orientation_p = 4;
  bool has_orientation_p() const;
  void clear_orientation_p();
  static const int kOrientationPFieldNumber = 4;
  private:
  void _slow_mutable_orientation_p();
  void _slow_set_allocated_orientation_p(
      ::google::protobuf::Arena* message_arena, ::mdlidar::Orientation** orientation_p);
  ::mdlidar::Orientation* _slow_release_orientation_p();
  public:
  const ::mdlidar::Orientation& orientation_p() const;
  ::mdlidar::Orientation* mutable_orientation_p();
  ::mdlidar::Orientation* release_orientation_p();
  void set_allocated_orientation_p(::mdlidar::Orientation* orientation_p);
  ::mdlidar::Orientation* unsafe_arena_release_orientation_p();
  void unsafe_arena_set_allocated_orientation_p(
      ::mdlidar::Orientation* orientation_p);

  // @@protoc_insertion_point(class_scope:mdlidar.State)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mdlidar::Vector3D* position_;
  ::mdlidar::Orientation* orientation_;
  ::mdlidar::Vector3D* position_p_;
  ::mdlidar::Orientation* orientation_p_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Point* other);
  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  protected:
  explicit Point(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float range = 1;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  float range() const;
  void set_range(float value);

  // float rotation = 2;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  float rotation() const;
  void set_rotation(float value);

  // int32 object_id = 3;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  ::google::protobuf::int32 object_id() const;
  void set_object_id(::google::protobuf::int32 value);

  // bool dynamic = 4;
  void clear_dynamic();
  static const int kDynamicFieldNumber = 4;
  bool dynamic() const;
  void set_dynamic(bool value);

  // @@protoc_insertion_point(class_scope:mdlidar.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float range_;
  float rotation_;
  ::google::protobuf::int32 object_id_;
  bool dynamic_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Frame* other);
  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  inline Frame* New() const PROTOBUF_FINAL { return New(NULL); }

  Frame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Frame* other);
  protected:
  explicit Frame(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mdlidar.Point points = 3;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  const ::mdlidar::Point& points(int index) const;
  ::mdlidar::Point* mutable_points(int index);
  ::mdlidar::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::mdlidar::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::mdlidar::Point >&
      points() const;

  // repeated .mdlidar.State object_state = 5;
  int object_state_size() const;
  void clear_object_state();
  static const int kObjectStateFieldNumber = 5;
  const ::mdlidar::State& object_state(int index) const;
  ::mdlidar::State* mutable_object_state(int index);
  ::mdlidar::State* add_object_state();
  ::google::protobuf::RepeatedPtrField< ::mdlidar::State >*
      mutable_object_state();
  const ::google::protobuf::RepeatedPtrField< ::mdlidar::State >&
      object_state() const;

  // .mdlidar.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  private:
  void _slow_mutable_state();
  void _slow_set_allocated_state(
      ::google::protobuf::Arena* message_arena, ::mdlidar::State** state);
  ::mdlidar::State* _slow_release_state();
  public:
  const ::mdlidar::State& state() const;
  ::mdlidar::State* mutable_state();
  ::mdlidar::State* release_state();
  void set_allocated_state(::mdlidar::State* state);
  ::mdlidar::State* unsafe_arena_release_state();
  void unsafe_arena_set_allocated_state(
      ::mdlidar::State* state);

  // int64 start_time = 1;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  ::google::protobuf::int64 start_time() const;
  void set_start_time(::google::protobuf::int64 value);

  // int64 end_time = 2;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  ::google::protobuf::int64 end_time() const;
  void set_end_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mdlidar.Frame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::mdlidar::Point > points_;
  ::google::protobuf::RepeatedPtrField< ::mdlidar::State > object_state_;
  ::mdlidar::State* state_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 end_time_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mdlidar.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Header* other);
  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 object_ids = 1;
  int object_ids_size() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  ::google::protobuf::uint32 object_ids(int index) const;
  void set_object_ids(int index, ::google::protobuf::uint32 value);
  void add_object_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      object_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_object_ids();

  // float delta_time = 2;
  void clear_delta_time();
  static const int kDeltaTimeFieldNumber = 2;
  float delta_time() const;
  void set_delta_time(float value);

  // int32 channels_count = 3;
  void clear_channels_count();
  static const int kChannelsCountFieldNumber = 3;
  ::google::protobuf::int32 channels_count() const;
  void set_channels_count(::google::protobuf::int32 value);

  // uint32 points_count_by_channel = 4;
  void clear_points_count_by_channel();
  static const int kPointsCountByChannelFieldNumber = 4;
  ::google::protobuf::uint32 points_count_by_channel() const;
  void set_points_count_by_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mdlidar.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > object_ids_;
  mutable int _object_ids_cached_byte_size_;
  float delta_time_;
  ::google::protobuf::int32 channels_count_;
  ::google::protobuf::uint32 points_count_by_channel_;
  mutable int _cached_size_;
  friend struct protobuf_mdlidar_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector3D

// float x = 1;
inline void Vector3D::clear_x() {
  x_ = 0;
}
inline float Vector3D::x() const {
  // @@protoc_insertion_point(field_get:mdlidar.Vector3D.x)
  return x_;
}
inline void Vector3D::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Vector3D.x)
}

// float y = 2;
inline void Vector3D::clear_y() {
  y_ = 0;
}
inline float Vector3D::y() const {
  // @@protoc_insertion_point(field_get:mdlidar.Vector3D.y)
  return y_;
}
inline void Vector3D::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Vector3D.y)
}

// float z = 3;
inline void Vector3D::clear_z() {
  z_ = 0;
}
inline float Vector3D::z() const {
  // @@protoc_insertion_point(field_get:mdlidar.Vector3D.z)
  return z_;
}
inline void Vector3D::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Vector3D.z)
}

// -------------------------------------------------------------------

// Orientation

// .mdlidar.Vector3D axis = 1;
inline bool Orientation::has_axis() const {
  return this != internal_default_instance() && axis_ != NULL;
}
inline void Orientation::clear_axis() {
  if (GetArenaNoVirtual() == NULL && axis_ != NULL) delete axis_;
  axis_ = NULL;
}
inline const ::mdlidar::Vector3D& Orientation::axis() const {
  // @@protoc_insertion_point(field_get:mdlidar.Orientation.axis)
  return axis_ != NULL ? *axis_
                         : *::mdlidar::Vector3D::internal_default_instance();
}
inline ::mdlidar::Vector3D* Orientation::mutable_axis() {
  
  if (axis_ == NULL) {
    _slow_mutable_axis();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.Orientation.axis)
  return axis_;
}
inline ::mdlidar::Vector3D* Orientation::release_axis() {
  // @@protoc_insertion_point(field_release:mdlidar.Orientation.axis)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_axis();
  } else {
    ::mdlidar::Vector3D* temp = axis_;
    axis_ = NULL;
    return temp;
  }
}
inline  void Orientation::set_allocated_axis(::mdlidar::Vector3D* axis) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete axis_;
  }
  if (axis != NULL) {
    _slow_set_allocated_axis(message_arena, &axis);
  }
  axis_ = axis;
  if (axis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.Orientation.axis)
}

// float angle = 2;
inline void Orientation::clear_angle() {
  angle_ = 0;
}
inline float Orientation::angle() const {
  // @@protoc_insertion_point(field_get:mdlidar.Orientation.angle)
  return angle_;
}
inline void Orientation::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Orientation.angle)
}

// -------------------------------------------------------------------

// State

// .mdlidar.Vector3D position = 1;
inline bool State::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void State::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::mdlidar::Vector3D& State::position() const {
  // @@protoc_insertion_point(field_get:mdlidar.State.position)
  return position_ != NULL ? *position_
                         : *::mdlidar::Vector3D::internal_default_instance();
}
inline ::mdlidar::Vector3D* State::mutable_position() {
  
  if (position_ == NULL) {
    _slow_mutable_position();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.State.position)
  return position_;
}
inline ::mdlidar::Vector3D* State::release_position() {
  // @@protoc_insertion_point(field_release:mdlidar.State.position)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_position();
  } else {
    ::mdlidar::Vector3D* temp = position_;
    position_ = NULL;
    return temp;
  }
}
inline  void State::set_allocated_position(::mdlidar::Vector3D* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position != NULL) {
    _slow_set_allocated_position(message_arena, &position);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.State.position)
}

// .mdlidar.Orientation orientation = 2;
inline bool State::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void State::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::mdlidar::Orientation& State::orientation() const {
  // @@protoc_insertion_point(field_get:mdlidar.State.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::mdlidar::Orientation::internal_default_instance();
}
inline ::mdlidar::Orientation* State::mutable_orientation() {
  
  if (orientation_ == NULL) {
    _slow_mutable_orientation();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.State.orientation)
  return orientation_;
}
inline ::mdlidar::Orientation* State::release_orientation() {
  // @@protoc_insertion_point(field_release:mdlidar.State.orientation)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_orientation();
  } else {
    ::mdlidar::Orientation* temp = orientation_;
    orientation_ = NULL;
    return temp;
  }
}
inline  void State::set_allocated_orientation(::mdlidar::Orientation* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation != NULL) {
    _slow_set_allocated_orientation(message_arena, &orientation);
  }
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.State.orientation)
}

// .mdlidar.Vector3D position_p = 3;
inline bool State::has_position_p() const {
  return this != internal_default_instance() && position_p_ != NULL;
}
inline void State::clear_position_p() {
  if (GetArenaNoVirtual() == NULL && position_p_ != NULL) delete position_p_;
  position_p_ = NULL;
}
inline const ::mdlidar::Vector3D& State::position_p() const {
  // @@protoc_insertion_point(field_get:mdlidar.State.position_p)
  return position_p_ != NULL ? *position_p_
                         : *::mdlidar::Vector3D::internal_default_instance();
}
inline ::mdlidar::Vector3D* State::mutable_position_p() {
  
  if (position_p_ == NULL) {
    _slow_mutable_position_p();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.State.position_p)
  return position_p_;
}
inline ::mdlidar::Vector3D* State::release_position_p() {
  // @@protoc_insertion_point(field_release:mdlidar.State.position_p)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_position_p();
  } else {
    ::mdlidar::Vector3D* temp = position_p_;
    position_p_ = NULL;
    return temp;
  }
}
inline  void State::set_allocated_position_p(::mdlidar::Vector3D* position_p) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_p_;
  }
  if (position_p != NULL) {
    _slow_set_allocated_position_p(message_arena, &position_p);
  }
  position_p_ = position_p;
  if (position_p) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.State.position_p)
}

// .mdlidar.Orientation orientation_p = 4;
inline bool State::has_orientation_p() const {
  return this != internal_default_instance() && orientation_p_ != NULL;
}
inline void State::clear_orientation_p() {
  if (GetArenaNoVirtual() == NULL && orientation_p_ != NULL) delete orientation_p_;
  orientation_p_ = NULL;
}
inline const ::mdlidar::Orientation& State::orientation_p() const {
  // @@protoc_insertion_point(field_get:mdlidar.State.orientation_p)
  return orientation_p_ != NULL ? *orientation_p_
                         : *::mdlidar::Orientation::internal_default_instance();
}
inline ::mdlidar::Orientation* State::mutable_orientation_p() {
  
  if (orientation_p_ == NULL) {
    _slow_mutable_orientation_p();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.State.orientation_p)
  return orientation_p_;
}
inline ::mdlidar::Orientation* State::release_orientation_p() {
  // @@protoc_insertion_point(field_release:mdlidar.State.orientation_p)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_orientation_p();
  } else {
    ::mdlidar::Orientation* temp = orientation_p_;
    orientation_p_ = NULL;
    return temp;
  }
}
inline  void State::set_allocated_orientation_p(::mdlidar::Orientation* orientation_p) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_p_;
  }
  if (orientation_p != NULL) {
    _slow_set_allocated_orientation_p(message_arena, &orientation_p);
  }
  orientation_p_ = orientation_p;
  if (orientation_p) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.State.orientation_p)
}

// -------------------------------------------------------------------

// Point

// float range = 1;
inline void Point::clear_range() {
  range_ = 0;
}
inline float Point::range() const {
  // @@protoc_insertion_point(field_get:mdlidar.Point.range)
  return range_;
}
inline void Point::set_range(float value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Point.range)
}

// float rotation = 2;
inline void Point::clear_rotation() {
  rotation_ = 0;
}
inline float Point::rotation() const {
  // @@protoc_insertion_point(field_get:mdlidar.Point.rotation)
  return rotation_;
}
inline void Point::set_rotation(float value) {
  
  rotation_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Point.rotation)
}

// int32 object_id = 3;
inline void Point::clear_object_id() {
  object_id_ = 0;
}
inline ::google::protobuf::int32 Point::object_id() const {
  // @@protoc_insertion_point(field_get:mdlidar.Point.object_id)
  return object_id_;
}
inline void Point::set_object_id(::google::protobuf::int32 value) {
  
  object_id_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Point.object_id)
}

// bool dynamic = 4;
inline void Point::clear_dynamic() {
  dynamic_ = false;
}
inline bool Point::dynamic() const {
  // @@protoc_insertion_point(field_get:mdlidar.Point.dynamic)
  return dynamic_;
}
inline void Point::set_dynamic(bool value) {
  
  dynamic_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Point.dynamic)
}

// -------------------------------------------------------------------

// Frame

// int64 start_time = 1;
inline void Frame::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Frame::start_time() const {
  // @@protoc_insertion_point(field_get:mdlidar.Frame.start_time)
  return start_time_;
}
inline void Frame::set_start_time(::google::protobuf::int64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Frame.start_time)
}

// int64 end_time = 2;
inline void Frame::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Frame::end_time() const {
  // @@protoc_insertion_point(field_get:mdlidar.Frame.end_time)
  return end_time_;
}
inline void Frame::set_end_time(::google::protobuf::int64 value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Frame.end_time)
}

// repeated .mdlidar.Point points = 3;
inline int Frame::points_size() const {
  return points_.size();
}
inline void Frame::clear_points() {
  points_.Clear();
}
inline const ::mdlidar::Point& Frame::points(int index) const {
  // @@protoc_insertion_point(field_get:mdlidar.Frame.points)
  return points_.Get(index);
}
inline ::mdlidar::Point* Frame::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:mdlidar.Frame.points)
  return points_.Mutable(index);
}
inline ::mdlidar::Point* Frame::add_points() {
  // @@protoc_insertion_point(field_add:mdlidar.Frame.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mdlidar::Point >*
Frame::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:mdlidar.Frame.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mdlidar::Point >&
Frame::points() const {
  // @@protoc_insertion_point(field_list:mdlidar.Frame.points)
  return points_;
}

// .mdlidar.State state = 4;
inline bool Frame::has_state() const {
  return this != internal_default_instance() && state_ != NULL;
}
inline void Frame::clear_state() {
  if (GetArenaNoVirtual() == NULL && state_ != NULL) delete state_;
  state_ = NULL;
}
inline const ::mdlidar::State& Frame::state() const {
  // @@protoc_insertion_point(field_get:mdlidar.Frame.state)
  return state_ != NULL ? *state_
                         : *::mdlidar::State::internal_default_instance();
}
inline ::mdlidar::State* Frame::mutable_state() {
  
  if (state_ == NULL) {
    _slow_mutable_state();
  }
  // @@protoc_insertion_point(field_mutable:mdlidar.Frame.state)
  return state_;
}
inline ::mdlidar::State* Frame::release_state() {
  // @@protoc_insertion_point(field_release:mdlidar.Frame.state)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_state();
  } else {
    ::mdlidar::State* temp = state_;
    state_ = NULL;
    return temp;
  }
}
inline  void Frame::set_allocated_state(::mdlidar::State* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state != NULL) {
    _slow_set_allocated_state(message_arena, &state);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mdlidar.Frame.state)
}

// repeated .mdlidar.State object_state = 5;
inline int Frame::object_state_size() const {
  return object_state_.size();
}
inline void Frame::clear_object_state() {
  object_state_.Clear();
}
inline const ::mdlidar::State& Frame::object_state(int index) const {
  // @@protoc_insertion_point(field_get:mdlidar.Frame.object_state)
  return object_state_.Get(index);
}
inline ::mdlidar::State* Frame::mutable_object_state(int index) {
  // @@protoc_insertion_point(field_mutable:mdlidar.Frame.object_state)
  return object_state_.Mutable(index);
}
inline ::mdlidar::State* Frame::add_object_state() {
  // @@protoc_insertion_point(field_add:mdlidar.Frame.object_state)
  return object_state_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mdlidar::State >*
Frame::mutable_object_state() {
  // @@protoc_insertion_point(field_mutable_list:mdlidar.Frame.object_state)
  return &object_state_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mdlidar::State >&
Frame::object_state() const {
  // @@protoc_insertion_point(field_list:mdlidar.Frame.object_state)
  return object_state_;
}

// -------------------------------------------------------------------

// Header

// repeated uint32 object_ids = 1;
inline int Header::object_ids_size() const {
  return object_ids_.size();
}
inline void Header::clear_object_ids() {
  object_ids_.Clear();
}
inline ::google::protobuf::uint32 Header::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:mdlidar.Header.object_ids)
  return object_ids_.Get(index);
}
inline void Header::set_object_ids(int index, ::google::protobuf::uint32 value) {
  object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mdlidar.Header.object_ids)
}
inline void Header::add_object_ids(::google::protobuf::uint32 value) {
  object_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mdlidar.Header.object_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Header::object_ids() const {
  // @@protoc_insertion_point(field_list:mdlidar.Header.object_ids)
  return object_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Header::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:mdlidar.Header.object_ids)
  return &object_ids_;
}

// float delta_time = 2;
inline void Header::clear_delta_time() {
  delta_time_ = 0;
}
inline float Header::delta_time() const {
  // @@protoc_insertion_point(field_get:mdlidar.Header.delta_time)
  return delta_time_;
}
inline void Header::set_delta_time(float value) {
  
  delta_time_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Header.delta_time)
}

// int32 channels_count = 3;
inline void Header::clear_channels_count() {
  channels_count_ = 0;
}
inline ::google::protobuf::int32 Header::channels_count() const {
  // @@protoc_insertion_point(field_get:mdlidar.Header.channels_count)
  return channels_count_;
}
inline void Header::set_channels_count(::google::protobuf::int32 value) {
  
  channels_count_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Header.channels_count)
}

// uint32 points_count_by_channel = 4;
inline void Header::clear_points_count_by_channel() {
  points_count_by_channel_ = 0u;
}
inline ::google::protobuf::uint32 Header::points_count_by_channel() const {
  // @@protoc_insertion_point(field_get:mdlidar.Header.points_count_by_channel)
  return points_count_by_channel_;
}
inline void Header::set_points_count_by_channel(::google::protobuf::uint32 value) {
  
  points_count_by_channel_ = value;
  // @@protoc_insertion_point(field_set:mdlidar.Header.points_count_by_channel)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mdlidar

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mdlidar_2eproto__INCLUDED
